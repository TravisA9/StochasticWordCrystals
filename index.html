<!DOCTYPE html>
<!-- saved from url=(0043)http://miamyanmar.com/economics/canvas.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Wordspace</title>
</head>
<body style="background:#222;">
<style type="text/css">
	button{
		border-bottom: 0px;
		background: white;
		margin-bottom: 0px;
		padding: 3px 10px 3px 10px;
		border-radius: 5px 5px 0px 0px;
	}
	button:hover{background: pink;}
</style>



<!-- <button onclick="start()"></button> -->
<button onclick="Matrix()">Matrix</button>
<button id="pause" onclick="start()">Graph</button>
<br>
<canvas id="myCanvas" width="650" height="650" style="background: white; display:inline-block;"></canvas>
<div class="slidecontainer" style="display:inline-block; vertical-align:top; width:44%; color:white;">
	Repulsion:<br>
  <input type="range" min=".001" value=".01" max=".5" step=".001" id="repulse" style="width:400px"><br>
    Temporal Attraction:<br>
  <input type="range" min=".001" value=".01" max=".5" step=".001" id="time" style="width:400px"><br>
    Identity Attraction:<br>
  <input type="range" min=".0001" value=".001" max=".01" step=".001" id="identity" style="width:400px"><br>

</div>

<h2>Paste the text you would like to anylise here:</h2>
<div id="content" contenteditable="true" style="font-size:18px; border: medium solid steelblue; border-radius: 9px; padding: 8px; color:white;">An AI Register for each city was introduced in beta today as part of the Next Generation Internet Policy Summit, organized in part by the European Commission and the city of Amsterdam. The Amsterdam registry currently features a handful of algorithms, but it will be extended to include all algorithms following the collection of feedback at the virtual conference to lay out a European vision of the future of the internet, according to a city official. Each algorithm cited in the registry lists datasets used to train a model, a description of how an algorithm is used, how humans utilize the prediction, and how algorithms were assessed for potential bias or risks. The registry also provides citizens a way to give feedback on algorithms their local government uses and the name, city department, and contact information for the person responsible for the responsible deployment of a particular algorithm. A complete algorithmic registry can empower citizens and give them a way to evaluate, examine, or question governments' applications of AI.</div>
<script>
//////////////////////////////////// UTILITY ////////////////////////////////////
$ = (sel) => document.getElementById(sel);
randRange = (a,b) => a + ( Math.random() * (b-a) )
chooseOne = (x) => Math.floor( Math.random() * x.length )
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
	c = $("myCanvas");
	ctx = c.getContext("2d");
//////////////////////////////////////////////////////////////////////////////////
// In a way this is also a matrix but the matrix does not have a set meaning. Instead
// the matrix is like an abstract space where the meaning can be changed and derived.
//////////////////////////////////////////////////////////////////////////////////
nodes = []
text = ''

function start(){
	nodes = []
	text = $("content").innerHTML;
	for(var i = 1; i < text.length; i++){
		nodes.push({f:text[i-1], t:text[i], time:i, x:randRange(150,450), y:randRange(150,450)})
	}
	nodes.sort((a,b) => (a.t > b.t) ? 1 : ((b.t > a.t) ? -1 : 0)); 
	nodes.sort((a,b) => (a.f > b.f) ? 1 : ((b.f > a.f) ? -1 : 0)); 
	Graph()
}
start()
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
function Graph(){
	// console.log(1)
	ctx.beginPath();
	ctx.fillStyle = `#fffc`;
	ctx.fillRect(0, 0, 650, 650);

	for (var i = 1; i < nodes.length; i++){	
		ctx.fillStyle = `rgb(0,${nodes[i].f.charCodeAt()},${nodes[i].t.charCodeAt()})`;
		ctx.fillRect(nodes[i].x, nodes[i].y, 1, 1);
	}
		
	ctx.stroke(); 
}
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
setInterval(force, 500);
function force(){
	fibre(); 
	Graph()
}
/////////////////////////////////////////////////////////////////////////////////
dist = (x1, y1, x2, y2) => Math.sqrt((x1-=x2)*x1 +(y1-=y2)*y1)
size = (a,b) => b-a
/////////////////////////////////////////////////////////////////////////////////
function fibre( ){

	for(var i = 0; i < nodes.length-2; i++){
		a = nodes[i]
		for(var j = i+1; j < nodes.length-1; j++){
			b = nodes[j]
			var score = $("repulse").value //.01			
			// if(a.t==b.t) score+=1;
			// if(a.f==b.f) score+=1;
			if(a.f==b.f && a.t==b.t) score-= $("identity").value
			  

			// if(Math.abs(a.time-b.time)>5) score-=.005;
			// if(Math.abs(a.time-b.time)>3) score-=.05;
			if(Math.abs(a.time-b.time)>2) score-= $("time").value



			var points = scaleLine2(a.x,a.y, b.x,b.y, score)
			a.x = points.xa
			a.y = points.ya
			b.x = points.xb
			b.y = points.yb
			
		}
	}

}
/////////////////////////////////////////////////////////////////////////////////
function scaleLine2(x1, y1, x2, y2, at){
	var xlen = x2 - x1, ylen = y2 - y1;
  	var length = Math.sqrt(xlen*xlen + ylen*ylen);
	if(length<3) return {xa:x1, ya:y1, xb:x2, yb:y2};
	at = at * 50/length
	var ratio = -at / length;
	var ratio2 = (length+at) / length;
  return {
  		xa: x1 + (xlen * ratio), 
      ya: y1 + (ylen * ratio),
  		xb: x1 + (xlen * ratio2), 
      yb: y1 + (ylen * ratio2),
      }
}
/////////////////////////////////////////////////////////////////////////////////
// Move two values closer together by %
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// use timer to call Force and recalculate and redraw every tick
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
matrix = new Array(96).fill(0).map(() => new Array(96).fill(0));
letter = (n) => String.fromCharCode(n+32);
leterIndex = (l) => l.charCodeAt()-32;
	for(var i = 1; i < text.length; i++){
	 	matrix[leterIndex(text[i-1])][leterIndex(text[i])]++;
	}

//////////////////////////////////////////////////////////////////////////////////
function Matrix(){
	ctx.beginPath();

	for (var i = 1; i < matrix.length; i++){	
		let m = matrix[i]		
		for (var j = 1; j < m.length; j++){	
			if(m[j]==0) {ctx.fillStyle = "#fff";}
			else{ ctx.fillStyle = `rgb(0,${(m[j]*90)},0)`;}
			ctx.fillRect(i*4, j*4, 3, 3);
		}
	}
		
	ctx.stroke(); 
}
</script> 
</body></html>